'use strict';

var EventEmitter = require("events").EventEmitter;
var Utils = require("cyclon.p2p-common");

function NeighbourSet(logger) {

    Utils.checkArguments(arguments, 1);

    var neighbours = {};
    var myself = this;

    /**
     * Return a copy of the contents map
     */
    this.getContents = function () {
        return JSON.parse(JSON.stringify(neighbours));
    };

    /**
     * Does the set contain the neighbour with the specified ID?
     *
     * @param neighbourId
     * @returns {boolean}
     */
    this.contains = function (neighbourId) {
        return neighbours.hasOwnProperty(neighbourId);
    };

    /**
     * Insert a neighbour into the set
     *
     * @param neighbour
     */
    this.insert = function (neighbour) {
        if (neighbour.id === null || typeof(neighbour.id) === "undefined") {
            throw new Error("Attempted to add invalid neighbour " + JSON.stringify(neighbour));
        }
        neighbours[neighbour.id] = neighbour;
        myself.emit("change", "insert", neighbour);
    };

    /**
     * Remove the neighbour with the specified ID from the set
     *
     * @param neighbourId
     */
    this.remove = function (neighbourId) {
        var removed = neighbours[neighbourId];
        delete neighbours[neighbourId];
        myself.emit("change", "remove", removed);
    };

    /**
     * Get the neighbour with the specified ID
     *
     * @param id
     * @returns {*}
     */
    this.get = function (id) {
        return neighbours[id];
    };

    /**
     * Get the number of neighbours in the set
     *
     * @returns {number}
     */
    this.size = function () {
        return Object.keys(neighbours).length;
    };

    /**
     * Select a set for a shuffle
     *
     * @param shuffleSize
     */
    this.selectShuffleSet = function (shuffleSize) {
        var oldestId = this.findOldestId();

        if (typeof(oldestId) !== "undefined") {
            var otherIds = Object.keys(neighbours).filter(function (item) {
                return item !== oldestId;
            });
            var sample = [oldestId].concat(Utils.randomSample(otherIds, shuffleSize - 1));
            return sample.map(this.get);
        }
        else {
            return [];
        }
    };

    /**
     * Find the ID of the oldest neighbour entry
     *
     * @returns {number}
     */
    this.findOldestId = function () {
        var oldestAge = -1;
        var oldestId;
        for (var id in neighbours) {
            var entry = neighbours[id];
            if (entry.age > oldestAge) {
                oldestAge = entry.age;
                oldestId = id;
            }
        }

        return oldestId;
    };

    this.getRandomId = function(){

        let all = Object.getOwnPropertyNames(neighbours);
        if (all.length===0){
            return undefined;
        }
        let a = all[parseInt(Math.random()*all.length)];
        console.error("a: " + a);
        return a;
    }
    /**
     * Choose a random set of neighbours
     *
     * @param setSize The size of the set to choose
     */
    this.randomSelection = function (setSize) {
        return Utils.randomSample(Object.keys(neighbours), setSize).map(this.get);
    };

    /**
     * Increment the age of each neighbour by one
     */
    this.incrementAges = function () {
        for (var id in neighbours) {
            neighbours[id].age = neighbours[id].age + 1;
        }
    };

    /**
     * Update the node pointer if the witnessed pointer's sequence
     * is higher than the one we have. Keep the current age though.
     */
    this.mergeNodePointerIfNewer = function (node) {
        var myNode = this.get(node.id);
        if (myNode) {
            if (myNode.seq < node.seq) {
                node.age = myNode.age;
                neighbours[node.id] = node;
                this.emit("change", "update", node);
            }
        }
        else {
            logger.warn("Attempt was made to merge node not in set");
        }
    };
}

NeighbourSet.prototype = Object.create(EventEmitter.prototype);

module.exports = NeighbourSet;
